STL List

是一双向链表，可高效地进行插入删除元素。包括构造、方法等。
构造：
list<int> c0; //空链表 　　
list<int> c1(3); //建一个含三个默认值是0的元素的链表 　　
list<int> c2(5,2); //建一个含五个元素的链表，值都是2 　　
list<int> c4(c2); //建一个c2的copy链表 　　
list<int> c5(c1.begin(),c1.end()); ////c5含c1一个区域的元素[_First, _Last)。

方法:
assign() //分配值，有两个重载： 　　
c1.assign(++c2.begin(), c2.end()) //c1现在为(50,60)。 　　
c1.assign(7,4) //c1中现在为7个4,c1(4,4,4,4,4,4,4)。 　　
back() //返回最后一元素的引用： 　　
begin() //返回第一个元素的指针(iterator) 　　
clear() //删除所有元素 　　
empty() //判断是否链表为空 　　
end() //返回最后一个元素的下一位置的指针(list为空时end()=begin()) 　　
erase() //删除一个元素或一个区域的元素(两个重载) 　　front() //返回第一个元素的引用： 　　insert() //在指定位置插入一个或多个元素(三个重载)： 　　max_size() //返回链表最大可能长度(size_type就是int型)： 　　merge() //合并两个链表并使之默认升序(也可改)： 　　pop_back() //删除链表尾的一个元素 　　pop_front() //删除链表头的一元素 　　push_back() //增加一元素到链表尾 　　push_front() //增加一元素到链表头 　　rbegin() //返回链表最后一元素的后向指针(reverse_iterator or const) 　　rend() //返回链表第一元素的下一位置的后向指针 　　remove //()删除链表中匹配值的元素(匹配元素全部删除) 　　remove_if() //删除条件满足的元素(会遍历一遍链表) 　　resize() //重新定义链表长度(两重载)： 　　reverse() //反转链表: 　　size() //返回链表中元素个数 　　sort() //对链表排序，默认升序(可自定义) 　　splice() //对两个链表进行结合(三个重载) 　　swap() //交换两个链表(两个重载) 　　unique() //删除相邻重复元素(断言已经排序，因为它不会删除不相邻的相同元素) 　　STL中list的使用： 　　STL中的list就是一双向链表，可高效地进行插入删除元素。现总结一下它的操作。 　　文中所用到两个list对象c1,c2分别有元素c1(10,20,30) c2(40,50,60)。还有一个list<int>::iterator citer用来指向c1或c2元素。 　　list对象的声明构造()： 　　A. list<int>c0; //空链表 　　B. list<int>c1(3); //建一个含三个默认值是0的元素的链表 　　C. list<int>c2(5,2); //建一个含五个元素的链表，值都是2 　　D. list<int>c4(c2); //建一个c2的copy链表 　　E. list<int>c5(c1.begin(),c1.end()); 　　//c5含c1一个区域的元素[_First, _Last)。 　　1. assign()分配值，有两个重载： 　　c1.assign(++c2.begin(), c2.end()) //c1现在为(50,60)。 　　c1.assing(7,4) //c1中现在为7个4,c1(4,4,4,4,4,4,4)。 　　2. back()返回最后一元素的引用： 　　int i=c1.back(); //i=30 　　const int i=c2.back(); //i=60且不可修改 　　3. begin()返回第一个元素的指针(iterator) 　　citer=c1.begin(); // *citer=10 　　list<int>::const_iterator cciter=c1.begin(); //*cciter=10且为const。 　　4. clear()删除所有元素 　　c1.clear(); //c1为空 c1.size为0； 　　5. empty()判断是否链表为空 　　bool B=c1.empty(); //若c1为空B=true；否则B=false; 　　6. end()返回最后一个元素的下一位置的指针(list为空时end()=begin()) 　　citer=c1.end(); //*(--citer)=30; 　　同begin()返回一个常指针，不能修改其中元素。 　　7. erase()删除一个元素或一个区域的元素(两个重载) 　　c1.erase(c1.begin()); // c1现为(20,30); 　　c1.erase(++c1.begin(),c1.end()); //　c1现为(10); 　　8. front() 返回第一个元素的引用： 　　int i=c1.front(); //i=10; 　　const int i=c1.front(); //i=10且不可修改。 　　9. insert()在指定位置插入一个或多个元素(三个重载)： 　　c1.insert(++c1.begin(),100); //c1(10,100,20,30) 　　c1.insert(c1.begin(),2,200); //c1(200,200,20,30); 　　c1.insert(++c1.begin(),c2.begin(),--c2.end()); 　　//c1(10,40,50,20,30); 　　10. max_size()返回链表最大可能长度(size_type就是int型)： 　　list<int>::size_type i=c1.max_size(); //i=1073741823 　　11. merge()合并两个链表并使之默认升序(也可改)： 　　c2.merge(c1); //c1现为空;c2现为c2(10,20,30,40,50,60) 　　c2.merge(c1,greater<int>()); //同上，但c2现为降序 　　12. pop_back()删除链表尾的一个元素 　　c1.pop_back() //c1(10,20); 　　13. pop_front()删除链表头的一元素 　　c1.pop_front()　//c1(20,30) 　　14. push_back()增加一元素到链表尾 　　c1.push_back(100) //c1(10,20,30,100) 　　15. push_front()增加一元素到链表头 　　c1.push_front(100) //c1(100,10,20,30) 　　16. rbegin()返回链表最后一元素的后向指针(reverse_iterator or const) 　　list<int>::reverse_iterator riter=c1.rbegin(); //*riter=30 　　17. rend()返回链表第一元素的下一位置的后向指针 　　list<int>::reverse_iterator riter=c1.rend(); // *(--riter)=10 　　18. remove()删除链表中匹配值的元素(匹配元素全部删除) 　　c1.remove(10); //c1(20,30) 　　19. remove_if()删除条件满足的元素(会遍历一遍链表) 　　c1.remove_if( is_odd<int> () ); //c1(10,20,30)　 　　//is_odd自己写(表奇数)　 　　20. resize()重新定义链表长度(两重载)： 　　c1.resize(4) //c1(10,20,30,0)用默认值填补 　　c1.resize(4,100) //c1(10,20,30,100)用指定值填补 　　21. reverse()反转链表: 　　c1.reverse(); //c1(30,20,10) 　　22. size()返回链表中元素个数 　　list<int>::size_type i=c1.size(); //i=3 　　23. sort()对链表排序，默认升序(可自定义) 　　c1.sort(); //c1(10,20,30) 　　c1.sort(great<int>()); //c1(30,20,10) 　　24. splice()对两个链表进行结合(三个重载) 　　c1.splice(++c1.begin(),c2); 　　//c1(10,40,50,60,20,30) c2为空全合并 　　c1.splice(++c1.begin(),c2,++c2.begin()); 　　//c1(10,50,20,30) ; c2(40,60)　指定元素合并 　　c1.splice(++c1.begin(),c2,++c2.begin(),c2.end()); 　　//c1(10,50,60,20,30); c2(40) 指定范围合并 　　25. swap()交换两个链表(两个重载) 　　c1.swap(c2); //c1(40,50,60); 　　swap(c1,c2); //c1(40,50,60) 　　26. unique()删除相邻重复元素(断言已经排序，因为它不会删除不相邻的相同元素) 　　c1.unique(); 　　//假设c1开始(-10,10,10,20,20,-10)则之后为c1(-10,10,20,-10) 　　c1.unique(mypred); //自定义谓词[1]